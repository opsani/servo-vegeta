#!/usr/bin/env python3

from measure import Measure, ST_FAILED

import sys
import os
import time
import subprocess
import yaml
import json
import unicodedata
import string
import re

from threading import Timer

DESCRIPTION = "Vegeta plugin for the Opsani Continuous Integration Engine"
VERSION = "0.0.1"
REPORTING_INTERVAL = 15
HAS_CANCEL = True

DEFAULT_CONFIGURATION = {
    'rate': '500',
    'duration': '0',
    'targets': 'vegeta_targets',
    'format': 'http',
    'connections': '10000',
    'workers': '10',
    'max-workers': '18446744073709551615',
    'http2': 'true',
    'keepalive': 'true',
    'insecure': 'false',
}

METRICS = {
    'throughput': {
        'unit': 'requests/second'
    },
    'error_rate': {
        'unit': 'percent'
    },
    'latency_total': {
        'unit': 'milliseconds'
    },
    'latency_mean': {
        'unit': 'milliseconds'
    },
    'latency_50th': {
        'unit': 'milliseconds'
    },
    'latency_90th': {
        'unit': 'milliseconds'
    },
    'latency_95th': {
        'unit': 'milliseconds'
    },
    'latency_99th': {
        'unit': 'milliseconds'
    },
    'latency_max': {
        'unit': 'milliseconds'
    },
    'latency_min': {
        'unit': 'milliseconds'
    },
}

class Vegeta(Measure):

    def describe(self):
        return METRICS

    # overwrites super
    def handle_cancel(self, signal, frame):
        err = "Exiting due to signal: %s"%signal
        self.print_measure_error(err, ST_FAILED)
        try:
            self.proc.terminate()
        except:
            pass
        sys.exit(0)
    
    # Disable the progress timer by overloading the superclass
    # The progress timer and Vegeta get caught in a race that can
    # result in multiple progress updates getting written onto the
    # same line of stdout, resulting in invalid JSON
    def start_progress_timer(self):
        pass

    # overwrites super
    def measure(self):
        with open('./config.yaml') as f:
            config_from_file = yaml.load(f.read())['vegeta']
        vegeta_config = DEFAULT_CONFIGURATION.copy()
        vegeta_config.update(config_from_file)

        # Run the load test
        exit_code, command, report = self._run_vegeta(vegeta_config)
        metrics = self._metrics_from_vegeta_report(report) if report else {}
        annotations = {
            'command': command,
        }
        return (metrics, annotations)

    def _run_vegeta(self, config):
        prog_coefficient = 1.0
        prog_start = 0.0
        exit_code, vegeta_report = None, None

        # construct and run Vegeta command
        duration = config['duration']
        vegeta_attack_args = [
            'vegeta', 'attack',
            '-rate', config['rate'], 
            '-duration', config['duration'], 
            '-targets', config['targets'],            
            '-targets', config['targets'],
            '-format', config['format'],
            '-workers', config['workers'],
            '-max-workers', config['max-workers'],
            '-http2', config['http2'],
            '-keepalive', config['keepalive'],
            '-insecure', config['insecure']
        ]

        vegeta_report_args = [
            'vegeta', 'report', 
            '-type', 'json',
            '-every', str(REPORTING_INTERVAL) + 's'
        ]
        vegeta_cmd = ' '.join(vegeta_attack_args) + ' | ' + ' '.join(vegeta_report_args)
        self.debug("Running Vegeta: ", vegeta_cmd)
        self.print_progress(f"Vegeta started (vegeta_cmd)")
        vegeta_attack_proc = subprocess.Popen(vegeta_attack_args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        # Pipe the output from the attack process into the reporting process
        self.proc = subprocess.Popen(vegeta_report_args, stdin=vegeta_attack_proc.stdout, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        # start progress for time limited vegeta command: update every 5 seconds -
        # it is printed by default every 30 seconds
        duration_in_seconds = self._seconds_from_duration_str(duration)
        started_at = time.time()
        timer = repeatingTimer(REPORTING_INTERVAL, self._update_timed_progress, started_at, duration_in_seconds,
                            prog_start, prog_coefficient)
        timer.start()

        # loop and poll our process pipe to gather report data        
        try:
            stripped = lambda s: "".join(ch for ch in s if unicodedata.category(ch)[0]!="C")
            while True:
                output = self.proc.stdout.readline()                
                if output:
                    report_output = output.decode().strip()
                    # TODO: Hack. Why can't I get this crap stripped?
                    json_string = stripped(report_output).replace('[2J[0;0H', '')
                    vegeta_report = json.loads(json_string)
                    self.print_progress(f"Vegeta latest metrics: {self._metrics_from_vegeta_report(vegeta_report)}")
                if self.proc.poll() is not None:
                    # Child process has exited, stop polling
                    break
            exit_code = self.proc.returncode
            self.debug("Vegeta exited with exit code:", exit_code)
            self.print_progress(f"Vegeta exited with exit code: {exit_code}")
        except Exception as e:
            raise
        finally:
            timer.cancel()
        return exit_code, vegeta_cmd, vegeta_report

    # Parses a Golang duration string into seconds
    def _seconds_from_duration_str(self, duration_value):
        if duration_value.strip() == '0':
            return 0
        hours, minutes, seconds = 0, 0, 0
        for component in re.findall('\d+[hms]', duration_value):
            time = component[:-1]
            unit = component[-1]
            if unit == 'h': hours = int(time)
            if unit == 'm': minutes = int(time)
            if unit == 's': seconds = int(time)
        total_seconds = (hours * 60 * 60) + (minutes * 60) + seconds
        return total_seconds

    def _metrics_from_vegeta_report(self, report):
        if report is None:
            return None                    
        metrics = METRICS.copy()

        # Capture latency values
        for latency_key in ['total', 'mean', '50th', '95th', '99th', 'max', 'min']:
            latency_value = report['latencies'].get(latency_key, None)
            # Convert Nanonsecond -> Millisecond
            value = (latency_value * 0.000001) if latency_value is not None else None
            metrics['latency_' + latency_key]['value'] = value

        # Capture throughput
        metrics['throughput']['value'] = report['throughput']
        
        # Calculate error rate
        error_rate = 100 - (report['success'] * 100) # Fraction of success inverted into % of error
        metrics['error_rate']['value'] = error_rate
        return metrics

    # helper:  update timer based progress
    def _update_timed_progress(self, t_start, t_limit, prog_start, prog_coefficient):
        # When duration is 0, Vegeta is attacking forever
        if t_limit:
            prog = min(100.0, 100.0 * (time.time() - t_start) / t_limit)
            self.progress = min(100, int((prog_coefficient * prog) + prog_start))

class repeatingTimer():
    def __init__(self, seconds, func, *args):
        self.seconds = seconds
        self.func = func
        self.args = args
        self.thread = Timer(self.seconds, self.call_func)
    def call_func(self):
        self.func(*self.args)
        self.thread = Timer(self.seconds, self.call_func)
        self.thread.start()
    def start(self):
        self.thread.start()
    def cancel(self):
        self.thread.cancel()


if __name__ == '__main__':
    vegeta = Vegeta(VERSION, DESCRIPTION, HAS_CANCEL, REPORTING_INTERVAL)
    vegeta.run()
